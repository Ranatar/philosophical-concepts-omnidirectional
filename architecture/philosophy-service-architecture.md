# Архитектура сервиса философских концепций

## 1. Обзор системы

Сервис философских концепций представляет собой комплексную платформу для работы с философскими идеями, их анализа и синтеза с использованием возможностей искусственного интеллекта. Система позволяет пользователям создавать, визуализировать, анализировать и синтезировать философские концепции в структурированном виде, с возможностью интерактивного взаимодействия с моделью Claude.

### 1.1 Ключевые возможности

- Создание и визуализация графов философских концепций
- Структурированное представление философских категорий и связей между ними
- Генерация и управление философскими тезисами на основе графов концепций
- Синтез новых концепций на базе существующих
- Интеллектуальный анализ и обогащение концепций с помощью Claude
- Историческая контекстуализация и диалогическое представление концепций

### 1.2 Уровни работы с системой

Система поддерживает три основных уровня взаимодействия:
1. **Работа с графом концепции** - создание и редактирование категорий, связей и их характеристик
2. **Работа с тезисами концепции** - генерация, редактирование и анализ тезисов на основе графа
3. **Синтезирование новых концепций** - создание новых философских концепций на основе существующих

## 2. Высокоуровневая архитектура

Система построена на основе микросервисной архитектуры с разделением ответственности между различными компонентами.

### 2.1 Основные компоненты

- **Клиентская часть** - веб-интерфейс для взаимодействия с системой
- **API Gateway** - единая точка входа для всех API-запросов
- **Микросервисы** - специализированные сервисы для работы с различными аспектами системы
- **Базы данных** - комбинация различных типов БД для оптимальной работы с разными видами данных
- **Инфраструктурные сервисы** - кэширование, очереди сообщений, логирование
- **Интеграция с Claude API** - взаимодействие с ИИ-моделью для анализа и генерации контента

Общая архитектура системы представлена на диаграмме в файле system-architecture.mmd.

### 2.2 Микросервисы

1. **Сервис пользователей (User Service)** - управление пользователями, аутентификация, авторизация
2. **Сервис концепций (Concept Service)** - работа с метаданными философских концепций
3. **Сервис графов (Graph Service)** - управление графовым представлением концепций
4. **Сервис тезисов (Thesis Service)** - управление тезисами концепций
5. **Сервис синтеза (Synthesis Service)** - синтезирование новых концепций
6. **Сервис Claude (Claude Service)** - взаимодействие с Claude API
7. **Сервис исторической контекстуализации (Historical Context Service)** - поместка концепций в исторический контекст
8. **Сервис практического применения (Practical Application Service)** - анализ практической применимости концепций
9. **Сервис диалогической интерпретации (Dialogue Service)** - создание и анализ диалогов между концепциями
10. **Сервис эволюции концепций (Evolution Service)** - анализ возможных направлений эволюции концепций

## 3. Структура данных и базы данных

Система использует полиглотный подход к хранению данных, комбинируя различные типы баз данных для оптимальной работы с разными видами данных.

### 3.1 Реляционная база данных (PostgreSQL)

Используется для хранения структурированных данных, метаданных и отношений:

#### 3.1.1 Основные таблицы

- **Users** - данные пользователей
  - `user_id` (UUID, PK)
  - `username` (string)
  - `email` (string)
  - `password_hash` (string)
  - `created_at` (datetime)
  - `last_login` (datetime)
  - `user_settings` (json)

- **SharedApiKeys** - совместное использование ключей API
  - `share_id` (UUID, PK)
  - `owner_id` (UUID, FK → Users)
  - `shared_with_id` (UUID, FK → Users)
  - `shared_at` (datetime)
  - `expires_at` (datetime)
  - `is_active` (boolean)
  - `permissions` (json)

- **ApiKeyUsage** - отслеживание использования API
  - `usage_id` (UUID, PK)
  - `user_id` (UUID, FK → Users)
  - `usage_date` (datetime)
  - `operation_type` (string)
  - `tokens_used` (int)
  - `estimated_cost` (float)
  - `concept_id` (UUID, FK → Concepts)

- **Concepts** - метаданные концепций
  - `concept_id` (UUID, PK)
  - `creator_id` (UUID, FK → Users)
  - `name` (string)
  - `description` (text)
  - `creation_date` (datetime)
  - `last_modified` (datetime)
  - `is_synthesis` (boolean)
  - `parent_concepts` (json)
  - `synthesis_method` (string)
  - `focus` (string)
  - `innovation_degree` (int)
  - `historical_context` (string)

- **Philosophers** - данные о философах
  - `philosopher_id` (UUID, PK)
  - `name` (string)
  - `birth_year` (int)
  - `death_year` (int)
  - `description` (text)
  - `traditions` (json)

- **Traditions** - философские традиции
  - `tradition_id` (UUID, PK)
  - `name` (string)
  - `time_period` (string)
  - `description` (text)
  - `key_figures` (json)

- **ConceptPhilosophers** - связь между концепциями и философами
  - `id` (UUID, PK)
  - `concept_id` (UUID, FK → Concepts)
  - `philosopher_id` (UUID, FK → Philosophers)
  - `relationship_type` (string)

- **ConceptTraditions** - связь между концепциями и традициями
  - `id` (UUID, PK)
  - `concept_id` (UUID, FK → Concepts)
  - `tradition_id` (UUID, FK → Traditions)
  - `relationship_strength` (float)

- **UserActivity** - активность пользователей
  - `activity_id` (UUID, PK)
  - `user_id` (UUID, FK → Users)
  - `activity_type` (string)
  - `target_id` (UUID)
  - `activity_date` (datetime)
  - `details` (json)

- **ClaudeInteractions** - взаимодействия с Claude
  - `interaction_id` (UUID, PK)
  - `user_id` (UUID, FK → Users)
  - `concept_id` (UUID, FK → Concepts)
  - `query_type` (string)
  - `query_content` (text)
  - `response_content` (text)
  - `interaction_date` (datetime)
  - `processing_time` (float)

Схема реляционной базы данных представлена на диаграмие в файле relational-db-schema.mmd.

### 3.2 Графовая база данных (Neo4j)

Используется для эффективного хранения и обработки графов философских концепций:

#### 3.2.1 Основные узлы и отношения

- **Узлы**:
  - **Concept** (концепция):
    - `concept_id` (соответствует ID в PostgreSQL)
    - `name` (название концепции)
  
  - **Category** (философская категория):
    - `category_id` (уникальный идентификатор)
    - `concept_id` (ID родительской концепции)
    - `name` (название категории)
    - `definition` (краткое определение)
    - `centrality` (количественная характеристика центральности)
    - `certainty` (определённость категории)
    - `historical_significance` (историческая значимость)

- **Отношения**:
  - **INCLUDES** - связь от Concept к Category
  - **RELATED_TO** - связь между категориями с атрибутами:
    - `relationship_id` (уникальный идентификатор)
    - `type` (тип связи: иерархическая, причинно-следственная, и т.д.)
    - `direction` (направленность: однонаправленная, двунаправленная)
    - `strength` (сила связи)
    - `certainty` (определённость связи)
    - `traditions` (связанные традиции)
    - `philosophers` (связанные философы)

Визуальная схема графовой базы данных представлена на диаграмме в файле graph-db-schema.mmd.

### 3.3 Документная база данных (MongoDB)

Используется для хранения текстовых данных, тезисов и результатов взаимодействия с Claude:

#### 3.3.1 Основные коллекции

- **Theses** - философские тезисы
  - `thesis_id` (ObjectId)
  - `concept_id` (UUID, связь с Concepts в PostgreSQL)
  - `type` (string: онтологический, эпистемологический, и т.д.)
  - `content` (text)
  - `related_categories` (array of category_ids)
  - `style` (string: академический, популярный, афористичный)
  - `generation_parameters` (object)
  - `created_at` (date)
  - `parent_theses` (array of thesis_ids, для синтезированных тезисов)

- **CategoryDescriptions** - развернутые описания категорий
  - `description_id` (ObjectId)
  - `category_id` (UUID, связь с Category в Neo4j)
  - `detailed_description` (text)
  - `alternative_interpretations` (array of texts)
  - `historical_analogues` (array of objects)
  - `related_concepts` (array of objects)
  - `claude_generation_id` (UUID, связь с ClaudeInteraction)
  - `created_at` (date)
  - `last_modified` (date)

- **RelationshipDescriptions** - описания связей между категориями
  - `description_id` (ObjectId)
  - `relationship_id` (UUID, связь со связью в Neo4j)
  - `philosophical_foundation` (text)
  - `counterarguments` (array of texts)
  - `analogues` (array of objects)
  - `claude_generation_id` (UUID, связь с ClaudeInteraction)
  - `created_at` (date)
  - `last_modified` (date)

- **ConceptAnalyses** - анализы концепций
  - `analysis_id` (ObjectId)
  - `concept_id` (UUID, связь с Concepts в PostgreSQL)
  - `analysis_type` (string: критический, исторический, и т.д.)
  - `content` (text)
  - `generation_parameters` (object)
  - `claude_generation_id` (UUID, связь с ClaudeInteraction)
  - `created_at` (date)

- **Dialogues** - диалоги между концепциями
  - `dialogue_id` (ObjectId)
  - `concept_ids` (array of concept_ids)
  - `topic` (string)
  - `content` (text)
  - `claude_generation_id` (UUID, связь с ClaudeInteraction)
  - `generated_at` (date)
  - `parameters` (object)

- **HistoricalContexts** - исторические контексты концепций
  - `context_id` (ObjectId)
  - `concept_id` (UUID, связь с Concepts в PostgreSQL)
  - `time_period` (string)
  - `historical_analysis` (text)
  - `influences` (array of objects)
  - `contemporaries` (array of objects)
  - `subsequent_influence` (array of objects)
  - `claude_generation_id` (UUID, связь с ClaudeInteraction)
  - `created_at` (date)

- **PracticalApplications** - практические применения концепций
  - `application_id` (ObjectId)
  - `concept_id` (UUID, связь с Concepts в PostgreSQL)
  - `domains` (array of objects)
  - `application_analysis` (text)
  - `implementation_methods` (array of objects)
  - `relevance_mappings` (array of objects)
  - `claude_generation_id` (UUID, связь с ClaudeInteraction)
  - `created_at` (date)

- **DialogueInterpretations** - диалогические интерпретации
  - `dialogue_id` (ObjectId)
  - `philosophical_question` (string)
  - `dialogue_content` (text)
  - `discussion_points` (array of objects)
  - `arguments` (array of objects)
  - `concept_ids` (array of concept_ids)
  - `claude_generation_id` (UUID, связь с ClaudeInteraction)
  - `created_at` (date)

Подробная схема коллекций документной базы данных представлена на диаграмме в файле document-db-schema.json.

## 4. Микросервисы и их взаимодействие

Пример полного цикла взаимодействия между микросервисами показан на диаграмме последовательности в файле user-flow.mmd.

### 4.1 Сервис пользователей (User Service)

**Ответственность**:
- Регистрация и управление пользователями
- Аутентификация и авторизация
- Управление профилями и настройками пользователей
- Отслеживание активности пользователей

**Дополнительная ответственность**:
- Управление ключами API Claude пользователей
- Шифрование и дешифрование ключей API
- Управление совместным использованием ключей
- Отслеживание использования ключей API

**Взаимодействия**:
- Использует PostgreSQL для хранения данных пользователей
- Использует Redis для кэширования сессий и токенов
- Предоставляет API для аутентификации другим сервисам

**Основные API-эндпоинты**:
- `POST /users` - создание пользователя
- `POST /auth/login` - вход в систему
- `GET /users/{id}` - получение данных пользователя
- `PUT /users/{id}` - обновление данных пользователя
- `GET /users/{id}/activity` - получение активности пользователя

**Дополнительные API-эндпоинты**:
- `POST /users/{id}/api-key` - установка/обновление ключа API
- `DELETE /users/{id}/api-key` - удаление ключа API
- `GET /users/{id}/api-key/usage` - получение статистики использования
- `POST /users/{id}/api-key/share` - совместное использование ключа
- `GET /users/{id}/shared-keys` - получение доступных общих ключей

### 4.2 Сервис концепций (Concept Service)

**Ответственность**:
- Управление метаданными концепций
- Создание, редактирование и удаление концепций
- Поиск и фильтрация концепций
- Координация работы с графами и тезисами концепций

**Взаимодействия**:
- Использует PostgreSQL для хранения метаданных концепций
- Взаимодействует с Graph Service для работы с графами концепций
- Взаимодействует с Thesis Service для работы с тезисами
- Использует Redis для кэширования часто запрашиваемых концепций

**Основные API-эндпоинты**:
- `POST /concepts` - создание концепции
- `GET /concepts/{id}` - получение данных концепции
- `PUT /concepts/{id}` - обновление концепции
- `DELETE /concepts/{id}` - удаление концепции
- `GET /concepts` - поиск и фильтрация концепций
- `POST /concepts/{id}/name` - генерация или установка названия

### 4.3 Сервис графов (Graph Service)

**Ответственность**:
- Управление графовым представлением концепций
- Создание и редактирование категорий и связей
- Валидация структуры графа
- Экспорт графа для визуализации и анализа

**Взаимодействия**:
- Использует Neo4j для хранения графов концепций
- Взаимодействует с Claude Service для валидации и обогащения графа
- Использует Redis для кэширования частей графа

**Основные API-эндпоинты**:
- `POST /graphs/concepts/{concept_id}/categories` - создание категории
- `PUT /graphs/categories/{id}` - обновление категории
- `DELETE /graphs/categories/{id}` - удаление категории
- `POST /graphs/relationships` - создание связи
- `PUT /graphs/relationships/{id}` - обновление связи
- `DELETE /graphs/relationships/{id}` - удаление связи
- `GET /graphs/concepts/{concept_id}` - получение полного графа концепции
- `POST /graphs/concepts/{concept_id}/validate` - валидация графа
- `POST /graphs/concepts/{concept_id}/enrich` - обогащение графа
- `POST /graphs/from-theses` - создание графа на основе тезисов
- `GET /graphs/analyze-origin` - анализ происхождения графа
- `GET /graphs/concepts/{concept_id}/characteristics` - получение количественных характеристик графа концепции
- `POST /graphs/categories/{id}/characteristics` - обновление количественных характеристик категории
- `POST /graphs/relationships/{id}/characteristics` - обновление количественных характеристик связи
- `POST /graphs/categories/{id}/characteristics/metadata` - получение философского обоснования для характеристики категории
- `POST /graphs/relationships/{id}/characteristics/metadata` - получение философского обоснования для характеристики связи

### 4.4 Сервис тезисов (Thesis Service)

**Ответственность**:
- Управление тезисами концепций
- Генерация тезисов на основе графа
- Развитие и обоснование тезисов
- Сравнение и анализ тезисов

**Взаимодействия**:
- Использует MongoDB для хранения тезисов и связанных документов
- Взаимодействует с Graph Service для получения данных графа
- Взаимодействует с Claude Service для генерации и анализа тезисов
- Использует Redis для кэширования часто используемых тезисов

**Основные API-эндпоинты**:
- `POST /theses/concepts/{concept_id}` - создание тезисов
- `GET /theses/concepts/{concept_id}` - получение тезисов концепции
- `GET /theses/{id}` - получение конкретного тезиса
- `PUT /theses/{id}` - обновление тезиса
- `DELETE /theses/{id}` - удаление тезиса
- `POST /theses/{id}/elaborate` - развитие и обоснование тезиса
- `POST /theses/compare` - сравнение наборов тезисов
- `POST /theses/analyze-origin` - анализ происхождения тезисов
- `POST /theses/concepts/{concept_id}/generate-with-characteristics` - генерация тезисов с учётом количественных характеристик
- `POST /theses/compare` - сравнение наборов тезисов с разным учётом характеристик

### 4.5 Сервис синтеза (Synthesis Service)

**Ответственность**:
- Синтезирование новых концепций на основе существующих
- Анализ совместимости концепций
- Координация процесса синтеза с другими сервисами
- Оценка результатов синтеза

**Взаимодействия**:
- Взаимодействует с Graph Service для работы с графами
- Взаимодействует с Thesis Service для работы с тезисами
- Взаимодействует с Claude Service для выполнения синтеза
- Использует как Neo4j, так и MongoDB для хранения результатов

**Основные API-эндпоинты**:
- `POST /synthesis/analyze-compatibility` - анализ совместимости концепций
- `POST /synthesis` - создание новой синтезированной концепции
- `GET /synthesis/{id}` - получение данных синтеза
- `POST /synthesis/{id}/critique` - критический анализ синтезированной концепции
- `GET /synthesis/history` - получение истории синтезов
- `POST /synthesis/identify-concepts` - определение родительских концепций
- `POST /synthesis/evolution` - эволюция концепции
- `POST /synthesis/with-characteristics` - создание синтезированной концепции с учётом количественных характеристик
- `POST /synthesis/recalculate-characteristics` - пересчёт количественных характеристик для синтезированной концепции

### 4.6 Сервис Claude (Claude Service)

**Ответственность**:
- Взаимодействие с Claude API
- Форматирование запросов и обработка ответов
- Очередизация и приоритизация запросов
- Обеспечение асинхронных операций для тяжелых запросов

**Дополнительная ответственность**:
- Определение какой ключ API использовать (пользовательский или системный)
- Отслеживание использования ключей по пользователям
- Обработка ошибок, связанных с недействительными ключами
- Переключение на системный ключ при необходимости

**Взаимодействия**:
- Взаимодействует напрямую с Claude API
- Использует RabbitMQ для очередизации запросов
- Использует PostgreSQL для хранения истории взаимодействий
- Предоставляет API для всех других сервисов, требующих взаимодействия с Claude

**Основные API-эндпоинты**:
- `POST /claude/query` - отправка запроса (синхронный режим)
- `POST /claude/queue-query` - постановка запроса в очередь (асинхронный режим)
- `GET /claude/tasks/{id}` - получение статуса и результата асинхронного запроса
- `GET /claude/interactions` - получение истории взаимодействий
- `GET /claude/templates` - получение шаблонов запросов

### 4.7 Сервис анализа названий (Name Analysis Service)

**Ответственность**:
- Анализ названий концепций
- Соотнесение названий с содержанием концепций
- Предложение альтернативных названий
- Оценка соответствия названия концепции

**Взаимодействия**:
- Взаимодействует с Concept Service для получения данных концепций
- Взаимодействует с Graph Service для анализа графа концепции
- Взаимодействует с Thesis Service для анализа тезисов
- Взаимодействует с Claude Service для выполнения анализа

**Основные API-эндпоинты**:
- `POST /name-analysis/analyze` - анализ названия концепции
- `POST /name-analysis/suggest-alternatives` - предложение альтернативных названий
- `GET /name-analysis/history` - получение истории анализа названий

### 4.8 Сервис исторической контекстуализации (Historical Context Service)

**Ответственность**:
- Анализ исторического контекста философской концепции
- Определение возможных источников влияния
- Выявление современников со схожими или противоположными идеями
- Анализ потенциального влияния на последующие философские направления
- Оценка соответствия названия историческому контексту

**Взаимодействия**:
- Взаимодействует с Concept Service для получения данных концепций
- Взаимодействует с Graph Service для анализа структуры концепции
- Взаимодействует с Claude Service для выполнения исторической контекстуализации
- Использует PostgreSQL для хранения метаданных
- Использует MongoDB для хранения результатов анализа

**Основные API-эндпоинты**:
- `POST /historical-context/analyze` - создание исторической контекстуализации
- `GET /historical-context/concepts/{concept_id}` - получение исторической контекстуализации концепции
- `GET /historical-context/{id}` - получение конкретной исторической контекстуализации
- `PUT /historical-context/{id}` - обновление исторической контекстуализации
- `DELETE /historical-context/{id}` - удаление исторической контекстуализации
- `GET /historical-context/traditions/{tradition_id}` - получение концепций, связанных с традицией
- `GET /historical-context/philosophers/{philosopher_id}` - получение концепций, связанных с философом

### 4.9 Сервис практического применения (Practical Application Service)

**Ответственность**:
- Анализ возможностей практического применения философских концепций
- Определение областей практического применения (образование, этика, политика и т.д.)
- Выявление наиболее релевантных тезисов и категорий для каждой области
- Предложение способов операционализации философских концепций
- Оценка практической значимости концепций

**Взаимодействия**:
- Взаимодействует с Concept Service для получения данных концепций
- Взаимодействует с Graph Service для анализа структуры концепции
- Взаимодействует с Thesis Service для анализа тезисов
- Взаимодействует с Claude Service для выполнения анализа практического применения
- Использует MongoDB для хранения результатов анализа

**Основные API-эндпоинты**:
- `POST /practical-application/analyze` - создание анализа практического применения
- `GET /practical-application/concepts/{concept_id}` - получение анализа практического применения концепции
- `GET /practical-application/{id}` - получение конкретного анализа
- `PUT /practical-application/{id}` - обновление анализа
- `DELETE /practical-application/{id}` - удаление анализа
- `GET /practical-application/domains/{domain}` - получение концепций, применимых в определенной области
- `GET /practical-application/theses/{thesis_id}` - получение областей применения для конкретного тезиса

### 4.10 Сервис диалогической интерпретации (Dialogue Service)

**Ответственность**:
- Создание философских диалогов между представителями разных концепций
- Формулирование философских вопросов для диалогов
- Анализ логики аргументации в диалогах
- Выявление точек соприкосновения и непреодолимых разногласий
- Генерация структурированных дискуссий на философские темы

**Взаимодействия**:
- Взаимодействует с Concept Service для получения данных о концепциях
- Взаимодействует с Thesis Service для получения тезисов
- Взаимодействует с Claude Service для генерации диалогов
- Использует MongoDB для хранения диалогов
- Использует PostgreSQL для хранения метаданных о диалогах

**Основные API-эндпоинты**:
- `POST /dialogues` - создание нового диалога
- `GET /dialogues/{id}` - получение конкретного диалога
- `PUT /dialogues/{id}` - обновление диалога
- `DELETE /dialogues/{id}` - удаление диалога
- `GET /dialogues/concepts/{concept_id}` - получение диалогов с участием концепции
- `POST /dialogues/analyze` - анализ существующего диалога
- `GET /dialogues/questions` - получение предложений философских вопросов для диалога
- `GET /dialogues/arguments/{dialogue_id}` - получение структурированных аргументов из диалога

### 4.11 Сервис эволюции концепций (Evolution Service)

**Ответственность**:
- Анализ возможных направлений эволюции философских концепций
- Предложение изменений категорий и связей в свете современных научных открытий
- Анализ потенциального переосмысления концепций в современном контексте
- Предложение новых элементов для включения в концепцию
- Анализ возможных изменений названия концепции при её эволюции

**Взаимодействия**:
- Взаимодействует с Graph Service для работы с графами концепций
- Взаимодействует с Thesis Service для работы с тезисами
- Взаимодействует с Claude Service для анализа эволюции
- Использует PostgreSQL для хранения метаданных об эволюции
- Использует MongoDB для хранения результатов анализа

**Основные API-эндпоинты**:
- `POST /evolution/analyze` - создание анализа эволюции концепции
- `GET /evolution/concepts/{concept_id}` - получение анализа эволюции для концепции
- `GET /evolution/{id}` - получение конкретного анализа эволюции
- `PUT /evolution/{id}` - обновление анализа эволюции
- `DELETE /evolution/{id}` - удаление анализа эволюции
- `POST /evolution/suggest-changes` - предложение конкретных изменений для эволюции концепции
- `GET /evolution/scientific-context` - получение научного контекста для эволюции концепций

## 5. Взаимодействие с Claude

### 5.1 Форматирование запросов

Система использует структурированные шаблоны для формирования запросов к Claude, оптимизированные для различных задач:

#### 5.1.1 Примеры шаблонов

- **Валидация графа**:
  ```
  Проанализируй следующий граф категорий философской концепции [ДАННЫЕ ГРАФА]. 
  Выяви возможные логические противоречия, пропущенные важные категории или 
  связи, необычные отношения между категориями. Предложи возможные улучшения.
  ```

- **Обогащение категории**:
  ```
  Для следующей категории [НАЗВАНИЕ] с определением [ОПРЕДЕЛЕНИЕ]
  в контексте философской концепции [НАЗВАНИЕ КОНЦЕПЦИИ], предложи расширенное
  описание, возможные альтернативные трактовки, исторические аналоги и связанные концепты.
  Категория используется в традициях: [СПИСОК ТРАДИЦИЙ]
  Категория связана с философами: [СПИСОК ФИЛОСОФОВ]
  При обогащении учитывай указанные традиции и философов.
  ```

- **Генерация тезисов**:
  ```
  На основе следующего графа философской концепции [ДАННЫЕ ГРАФА] 
  сформулируй [КОЛИЧЕСТВО] ключевых тезисов в области [ТИП ТЕЗИСОВ]. 
  Тезисы должны отражать структурные отношения между категориями и быть 
  выражены в [СТИЛЬ] стиле. Для каждого тезиса укажи, из каких именно 
  элементов графа он логически следует.
  ```

- **Генерация графа из тезисов**:
  ```
  На основе следующих философских тезисов [СПИСОК ТЕЗИСОВ] создай
  структурированный граф концепции. Выдели ключевые категории, установи связи
  между ними и предложи иерархию. Для каждого элемента графа укажи, из каких
  именно тезисов он логически следует.
  ```

- **Анализ тезисов для выявления синтеза**:
  ```
  Проанализируй следующие философские тезисы [СПИСОК ТЕЗИСОВ].
  Определи, представляют ли они единую философскую перспективу или являются
  синтезом различных философских традиций. Если это синтез, идентифицируй возможные
  'родительские' философские традиции или концепции, которые могли быть объединены.
  Предоставь детальное обоснование своего анализа.
  ```

- **Анализ названия концепции**:
  ```
  Проанализируй название философской концепции [НАЗВАНИЕ КОНЦЕПЦИИ]
  в контексте её содержания [ДАННЫЕ КОНЦЕПЦИИ]. Насколько точно название отражает
  суть концепции? Какие аспекты концепции подчеркиваются в названии, а какие остаются
  в тени? Предложи возможные альтернативные названия, которые могли бы лучше
  отразить различные аспекты концепции.
  ```

### 5.2 Типы взаимодействия с Claude

#### 5.2.1 Синхронный режим
- Используется для быстрых операций (до 10 секунд)
- Непосредственный запрос-ответ через REST API
- Клиент ожидает ответа от сервера

#### 5.2.2 Асинхронный режим
- Используется для длительных операций (более 10 секунд)
- Запрос ставится в очередь RabbitMQ
- Клиент получает идентификатор задачи
- Результат доступен по отдельному запросу или через WebSocket

Диаграмма процесса взаимодействия с Claude представлена в файле claude-interaction.mmd.

### 5.3 Процесс обработки запросов к Claude

1. Подготовка данных (запрос к соответствующим базам данных)
2. Форматирование запроса с использованием соответствующего шаблона
3. Определение режима взаимодействия (синхронный/асинхронный)
4. Выполнение запроса к Claude API
5. Обработка и структурирование ответа
6. Сохранение результатов в соответствующие базы данных
7. Возврат результата клиенту

См. файл claude-requests.js с примером кода для форматирования запросов к Claude.

## 6. Пользовательский интерфейс

### 6.1 Основные модули UI

- **Домашняя страница** - обзор доступных концепций и функций
- **Список концепций** - просмотр и управление концепциями
- **Редактор концепций** - работа с графами и тезисами
- **Инструмент синтеза** - создание новых концепций
- **Профиль пользователя** - настройки и история активности
- 
Схема архитектуры пользовательского интерфейса представлена на диаграмме в файле ui-architecture.mmd.

### 6.2 Редактор концепций

#### 6.2.1 Редактор графа
- Интерактивная визуализация графа концепции
- Инструменты для добавления и редактирования категорий
- Инструменты для создания и настройки связей
- Редактор количественных характеристик
- Интеграция с Claude для валидации и обогащения графа

См. файл concept-graph-visualization.tsx с реализацией компонента визуализации графа концепции.

#### 6.2.2 Редактор тезисов
- Список и фильтрация тезисов
- Генератор тезисов с настраиваемыми параметрами
- Просмотр и редактирование деталей тезиса
- Инструменты для валидации и анализа тезисов
- Интеграция с Claude для обогащения и обоснования тезисов

#### 6.2.3 Интерфейс взаимодействия с Claude
- Шаблоны запросов для различных задач
- Свободная форма ввода для произвольных запросов
- История взаимодействий с возможностью повторного использования
- Интерактивное редактирование генерируемого контента
- Сохранение результатов в соответствующие структуры данных

См. файл claude-interface.tsx с реализацией пользовательского интерфейса для взаимодействия с Claude.

### 6.3 Инструмент синтеза

- Селектор концепций для синтеза
- Настройка параметров синтеза
- Предпросмотр результатов синтеза
- История синтезов с возможностью сравнения

## 7. Инфраструктура и развертывание

### 7.1 Контейнеризация

Все компоненты системы контейнеризированы с использованием Docker, что обеспечивает:
- Изоляцию зависимостей
- Стандартизацию сред выполнения
- Простоту развертывания
- Эффективное масштабирование

### 7.2 Оркестрация контейнеров

Для продакшн-окружения используется Kubernetes:
- Автоматическое масштабирование на основе нагрузки
- Самовосстановление при сбоях
- Балансировка нагрузки
- Управление конфигурацией и секретами

Схема развертывания системы представлена на диаграмме в файле deployment-architecture.mmd.

### 7.3 Локальное окружение разработки

Для разработки используется Docker Compose:
- Одна команда для запуска всей системы
- Согласованные версии сервисов и баз данных
- Возможность локального тестирования всей архитектуры
- Эмуляция продакшн-окружения

См. файл docker-compose-config.yaml с примером конфигурации Docker Compose для локальной разработки.

### 7.4 CI/CD

Непрерывная интеграция и доставка обеспечивают:
- Автоматическое тестирование при каждом изменении кода
- Автоматическое развертывание в тестовую среду
- Автоматизированное создание и публикация контейнеров
- Стратегии развертывания с нулевым временем простоя

## 8. Безопасность и масштабирование

### 8.1 Безопасность

- **Аутентификация и авторизация**:
  - JWT-токены для аутентификации между сервисами
  - RBAC (Role-Based Access Control) для авторизации
  - OAuth2 для интеграции с внешними системами

- **Защита данных**:
  - Шифрование чувствительных данных в БД
  - HTTPS для всех внешних соединений
  - Защита от SQL-инъекций и XSS-атак

- **Аудит и мониторинг**:
  - Логирование всех действий пользователей
  - Мониторинг активности с детекцией аномалий
  - Регулярные проверки безопасности

### 8.2 Масштабирование

- **Горизонтальное масштабирование**:
  - Все сервисы проектируются без состояния (stateless)
  - Автоматическое масштабирование в Kubernetes
  - Репликация баз данных

- **Оптимизация производительности**:
  - Кэширование с использованием Redis
  - Индексирование данных в базах
  - Асинхронная обработка тяжелых операций

- **Балансировка нагрузки**:
  - Балансировщики трафика для API-запросов
  - Распределение очередей сообщений
  - Приоритизация критических операций

## 9. Процессы и потоки данных

### 9.1 Создание и развитие концепции

1. Пользователь создает новую концепцию через UI
2. Concept Service создает запись в PostgreSQL
3. Пользователь добавляет категории и связи через UI
4. Graph Service сохраняет структуру графа в Neo4j
5. Пользователь запрашивает валидацию графа
6. Claude Service отправляет запрос к Claude и возвращает результат
7. Пользователь корректирует граф на основе результатов
8. Пользователь запрашивает генерацию тезисов
9. Thesis Service получает граф, формирует запрос к Claude Service
10. Сгенерированные тезисы сохраняются в MongoDB
11. Пользователь просматривает и редактирует тезисы

### 9.2 Синтез новых концепций

1. Пользователь выбирает концепции для синтеза
2. Synthesis Service запрашивает анализ совместимости через Claude Service
3. Пользователь настраивает параметры синтеза
4. Synthesis Service формирует запрос к Claude Service для синтеза графа
5. Новый граф сохраняется в Neo4j через Graph Service
6. Synthesis Service запрашивает генерацию тезисов для новой концепции
7. Новые тезисы сохраняются в MongoDB через Thesis Service
8. Synthesis Service запрашивает критический анализ синтезированной концепции
9. Результаты анализа сохраняются и представляются пользователю

### 9.3 Схема взаимодействия с Claude для обогащения категории

1. Пользователь выбирает категорию и запрашивает обогащение
2. UI отправляет запрос на API Gateway
3. Запрос направляется в Graph Service
4. Graph Service получает данные о категории, концепции, связанных традициях и философах
5. Graph Service формирует запрос к Claude Service
6. Claude Service форматирует запрос по шаблону
7. Claude Service отправляет запрос к Claude API
8. Claude API возвращает обогащенное описание
9. Claude Service обрабатывает ответ и возвращает результат
10. Graph Service сохраняет обогащенное описание в MongoDB через Thesis Service
11. Результат возвращается пользователю для просмотра и подтверждения

### 9.4 Двунаправленное преобразование (тезисы ↔ граф)

1. Пользователь создает тезисы через UI (напрямую, без графа)
2. Пользователь запрашивает генерацию графа на основе тезисов
3. UI отправляет запрос в Graph Service
4. Graph Service получает тезисы из Thesis Service
5. Graph Service формирует запрос к Claude Service для генерации графа
6. Claude Service отправляет запрос к Claude
7. Claude возвращает структуру графа
8. Graph Service проверяет наличие категорий и типов связей в базе
9. Если обнаружены новые элементы:
   - Graph Service сохраняет информацию о новых элементах в MongoDB
   - Graph Service возвращает граф с флагом requiresApproval
   - UI отображает компонент одобрения новых элементов
   - Пользователь просматривает, редактирует и одобряет/отклоняет новые элементы
   - При одобрении Graph Service добавляет новые элементы в соответствующие таблицы
10. Graph Service преобразует ответ в граф и сохраняет в Neo4j
11. Пользователь видит сгенерированный граф
12. Пользователь может редактировать граф и снова генерировать тезисы

### 9.5 Анализ названия концепции

1. Пользователь выбирает существующую концепцию
2. Пользователь запрашивает анализ названия
3. UI отправляет запрос в Name Analysis Service
4. Name Analysis Service получает данные концепции (граф, тезисы)
5. Name Analysis Service формирует запрос к Claude Service
6. Claude Service отправляет запрос к Claude
7. Claude возвращает анализ названия
8. Результаты анализа сохраняются и представляются пользователю
9. Пользователь может выбрать альтернативное название

### 9.6 Определение происхождения концепции

1. Пользователь загружает существующие тезисы или граф
2. Пользователь запрашивает анализ происхождения
3. UI отправляет запрос в Synthesis Service
4. Synthesis Service формирует запрос к Claude Service для анализа
5. Claude Service отправляет запрос к Claude
6. Claude возвращает анализ происхождения, определяя возможные родительские концепции
7. Результаты сохраняются и представляются пользователю
8. Система может предложить связать концепцию с определенными философскими традициями

### 9.7 Историческая контекстуализация

1. Пользователь выбирает концепцию и запрашивает историческую контекстуализацию
2. UI отправляет запрос в Historical Context Service
3. Historical Context Service получает данные о концепции, графе и тезисах
4. Historical Context Service формирует запрос к Claude Service
5. Claude Service отправляет запрос к Claude API
6. Claude API возвращает историческую контекстуализацию
7. Claude Service обрабатывает ответ и возвращает результат
8. Historical Context Service сохраняет результаты в MongoDB и PostgreSQL
9. Результаты возвращаются пользователю для просмотра

### 9.8 Практическое применение

1. Пользователь выбирает концепцию и запрашивает анализ практического применения
2. UI отправляет запрос в Practical Application Service
3. Practical Application Service получает данные о концепции, графе, категориях и тезисах
4. Practical Application Service формирует запрос к Claude Service
5. Claude Service отправляет запрос к Claude API
6. Claude API возвращает анализ практического применения
7. Claude Service обрабатывает ответ и возвращает результат
8. Practical Application Service сохраняет результаты в MongoDB
9. Результаты возвращаются пользователю с разбивкой по областям применения

### 9.9 Диалогическая интерпретация

1. Пользователь выбирает две концепции и философский вопрос для диалога
2. UI отправляет запрос в Dialogue Service
3. Dialogue Service получает данные о концепциях и их тезисах
4. Dialogue Service формирует запрос к Claude Service
5. Claude Service отправляет запрос к Claude API
6. Claude API возвращает философский диалог
7. Claude Service обрабатывает ответ и возвращает результат
8. Dialogue Service сохраняет диалог в MongoDB
9. Dialogue Service сохраняет метаданные о диалоге в PostgreSQL
10. Диалог возвращается пользователю для просмотра и анализа

### 9.10 Эволюция концепции

1. Пользователь выбирает концепцию и запрашивает анализ эволюции
2. UI отправляет запрос в Evolution Service
3. Evolution Service получает данные о концепции, графе и тезисах
4. Evolution Service формирует запрос к Claude Service
5. Claude Service отправляет запрос к Claude API
6. Claude API возвращает анализ возможных направлений эволюции
7. Claude Service обрабатывает ответ и возвращает результат
8. Evolution Service сохраняет результаты в MongoDB и PostgreSQL
9. Evolution Service предлагает варианты изменения графа и тезисов
10. Результаты возвращаются пользователю с возможностью применения предложенных изменений

### 9.11 Управление ключами API Claude

1. Пользователь переходит в настройки профиля
2. Пользователь вводит свой ключ API Claude
3. UI отправляет запрос в User Service
4. User Service шифрует ключ и сохраняет в PostgreSQL
5. При последующих запросах к Claude:
   - Claude Service проверяет наличие пользовательского ключа
   - Если ключ есть, использует его для запросов
   - Если ключа нет или он недействителен, использует системный ключ
6. Claude Service отслеживает использование и сохраняет статистику
7. Пользователь может просматривать статистику использования и делиться ключом

## 10. Заключение

Архитектура сервиса философских концепций представляет собой комплексное решение, объединяющее современные подходы к проектированию распределенных систем с предметно-ориентированным дизайном для работы с философскими категориями и концепциями.

Использование микросервисной архитектуры, полиглотного подхода к хранению данных и интеграции с Claude обеспечивает гибкость, масштабируемость и интеллектуальные возможности системы, позволяя эффективно работать с комплексными философскими концепциями, их анализом и синтезом.

Система предоставляет интуитивный пользовательский интерфейс для работы на всех уровнях взаимодействия - от создания и визуализации графов до синтеза новых концепций, обеспечивая мощный инструментарий как для исследовательской работы, так и для образовательных целей в области философии.
